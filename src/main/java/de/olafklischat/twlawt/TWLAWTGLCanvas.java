package de.olafklischat.twlawt;

import java.awt.AWTEvent;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;

import javax.swing.Timer;

import org.lwjgl.LWJGLException;
import org.lwjgl.opengl.AWTGLCanvas;
import org.lwjgl.opengl.GL11;

import de.matthiasmann.twl.GUI;
import de.matthiasmann.twl.renderer.lwjgl.LWJGLRenderer;

public abstract class TWLAWTGLCanvas extends AWTGLCanvas {

    private LWJGLRenderer renderer;
    private GUI gui;
    private Timer guiUpdateTimer;
    private boolean resizePending = true;


    public TWLAWTGLCanvas() throws LWJGLException {
        super();
        enableEvents(AWTEvent.MOUSE_EVENT_MASK|AWTEvent.MOUSE_MOTION_EVENT_MASK|AWTEvent.MOUSE_WHEEL_EVENT_MASK);
        guiUpdateTimer = new Timer(100, new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                if (getGUI() == null) {
                    return;
                }
                TWLAWTGLCanvas.this.repaint();
            }
        });
        guiUpdateTimer.start();
    }
    
    @Override
    protected void processMouseEvent(MouseEvent e) {
        super.processMouseEvent(e);
        processAnyMouseEvent(e);
    }
    
    @Override
    protected void processMouseMotionEvent(MouseEvent e) {
        super.processMouseMotionEvent(e);
        processAnyMouseEvent(e);
    }
    
    @Override
    protected void processMouseWheelEvent(MouseWheelEvent e) {
        super.processMouseWheelEvent(e);
        processAnyMouseEvent(e);
    }
    
    
    protected void processAnyMouseEvent(MouseEvent e) {
        if (e.isConsumed()) {
            return;
        }
        if (getGUI() == null) {
            return;
        }
        //TODO: in some cases, TWL-internal mouse handlers require a valid
        // current GL context -- see doc/twl-lwjgl.txt for examples. Those
        // will fail here, of course. Maybe only queue up the mouse events
        // in here and dispatch them in paintGL? Would that incur undesired
        // semantical changes
        ModifiersState.setModifiers(e.getModifiers());
        boolean wasHandled = false;
        int id = e.getID();
        switch(id) {
          case MouseEvent.MOUSE_PRESSED:
              wasHandled = getGUI().handleMouse(e.getX(), e.getY(), TwlAwtEventUtil.mouseButtonAwtToTwl(e.getButton()), true);
              break;
          case MouseEvent.MOUSE_RELEASED:
              wasHandled = getGUI().handleMouse(e.getX(), e.getY(), TwlAwtEventUtil.mouseButtonAwtToTwl(e.getButton()), false);
              break;
          case MouseEvent.MOUSE_DRAGGED:
              wasHandled = getGUI().handleMouse(e.getX(), e.getY(), -1, false);
              break;
          case MouseEvent.MOUSE_MOVED:
              wasHandled = getGUI().handleMouse(e.getX(), e.getY(), -1, false);
              break;
          case MouseEvent.MOUSE_WHEEL:
              wasHandled = getGUI().handleMouseWheel(((MouseWheelEvent)e).getWheelRotation() < 0 ? 1 : -1);
              break;
          // not forwarded / generated by TWL internally: mouseClicked, mouseEntered, mouseExited
        }
        if (wasHandled) {
            e.consume();
            TWLAWTGLCanvas.this.repaint();
        }
    }

    /**
     * Create the TWL GUI. The default overridden {@link #initGL()} calls this
     * and assigns the result to {@link #getGUI()}. This method should do any
     * necessary GUI setup/initializations.
     * 
     * @param renderer
     *            the LWJGLRenderer to use for the GUI. Created by
     *            {@link #createRenderer()}
     * @return the GUI
     */
    protected abstract GUI createGUI(LWJGLRenderer renderer) throws Exception;

    /**
     * 
     * @return the GUI object that should be the target for paint/mouse event
     *         dispatching etc. May be null at any time. Defaults to the GUI
     *         created by createGUI().
     */
    protected GUI getGUI() {
        return gui;
    }

    /**
     * Create the LWJGLRenderer to be passed to the
     * {@link #createGUI(LWJGLRenderer)} method.
     * 
     * @return
     * @throws LWJGLException
     */
    protected LWJGLRenderer createRenderer() throws LWJGLException {
        LWJGLRenderer renderer = new LWJGLRenderer();
        renderer.setUseSWMouseCursors(true);
        return renderer;
    }

    /**
     * 
     * @return the renderer to be used. Default to the one created by
     *         {@link #createRenderer()}.
     */
    protected LWJGLRenderer getRenderer() {
        return renderer;
    }

    /**
     * Callback called by initGL() after successful creation of the
     * {@link #getRenderer()} and the {@link #getGUI()}.
     */
    protected void onGuiCreated() {
        
    }
    
    /**
     * (Overridden) Calls super, creates the {@link #getRenderer()} and the
     * {@link #getGUI()} using {@link #createRenderer()} and
     * {@link #createGUI(LWJGLRenderer)}.
     */
    @Override
    protected void initGL() {
        super.initGL();
        try {
            renderer = createRenderer();
            gui = createGUI(renderer);
            onGuiCreated();
        } catch (Exception e) {
            throw new RuntimeException(e.getLocalizedMessage(), e);
        }
    }
    
    @Override
    protected void paintGL() {
        try {
            if (null == getGUI()) {
                return;
            }
            if (resizePending) {
                GL11.glViewport(0, 0, TWLAWTGLCanvas.this.getWidth(), TWLAWTGLCanvas.this.getHeight());
                getRenderer().syncViewportSize();
                getGUI().setSize();
                resizePending = false;
            }
            
            GL11.glClearColor(0, 0, 0, 1);
            GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);

            getGUI().setSize();
            getGUI().updateTime();
            getGUI().updateTimers();
            getGUI().invokeRunables();
            getGUI().validateLayout();
            getGUI().draw();
            getGUI().handleTooltips();  // TODO: better do this after dispatching mouse events in here?
            //getGUI().setCursor();
            swapBuffers();
        } catch (LWJGLException ex) {
            throw new RuntimeException(ex);
        }
    }
    
    
    @Override
    public void componentResized(ComponentEvent e) {
        super.componentResized(e);
        resizePending = true;
    }
}
